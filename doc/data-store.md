

## Entity messsage patterns

Each data store must define these patterns:

   * role:entity, cmd:load   - load a single entity, if it exists
   * role:entity, cmd:save   - save a single entity, creating it if needed
   * role:entity, cmd:list   - list entities matching a query condition
   * role:entity, cmd:count   - count entities matching a query condition
   * role:entity, cmd:remove - remove an entity
   * role:entity, cmd:native - provide access to the native driver

If the data store is loaded under an entity mapping, then the
following additional keys will potentially be part of pattern:

   * name
   * base
   * zone


Data stores may optionally define:

   * init:<store-name>, tag:<store-tag> - initialize the store (i.e. connect to the database)

Data stores may optionally subscribe to:

   * role:seneca, cmd:close - service shutdown; close database connection


## Pattern parameters

The role:entity, cmd:load;save;list;count;remove patterns must accept the
following parameters:

   * name: the name of the data entity, required
   * base: a namespace for the data entity, optional
   * zone: a metaspace for the data entity, optional


### cmd:load

This pattern must accept:

   * q: query to select an entity from the underlying data store

The query specifies a set of entity data fields that must match the
given values exactly. For example:

   * `q = {id:1}`: find the entity with _id_ field equal to the value `1`
   * `q = {foo:"bar"}`: find the entity with _foo_ field equal to the value `"bar"`
   * `q = {a:1,b:2}`: find the entity with _a_ field equal to the value `1`, and _b_ equal to 2

No other type of query is supported as standard, although some data
stores may provide additonal query options.

The _cmd:load_ pattern returns a single entity, the first row of the
query result set.

In addition to field values, the query can contain certain qualifiers:

   * sort$: a sub-object containing a single field, with value `1` to sort results in ascending order, and `-1` to sort descending
   * skip$: an integer > 0 indicating the number of result set rows to skip
   * limit$: an integer > 0 indicating the maximum number of result set rows to return, dropping any additional rows

If the qualifiers have invalid values, they are simply ignored.


### cmd:save

This pattern must accept:

   * ent: the entity object to save

If the entity has an _id_ field, this is used as the primary key by
the underlying database, and the save is considered an update operation.

If the entity does not have an _id_ field, one is generated by calling
_role:basic,cmd:generate_id_, and the save is considered an insert
operation.  Alternatively, the data store may provide other means of
identifier generation, parameterised by plugin options.

If the entity has an _id$_ field, this is used as the primary key, and
the save is considered to be an insert operation using the specified
key.


### cmd:remove

This pattern must accept:

   * q: query to select a set of entities from the underlying data store

The query qualifers are the same as for _cmd:load_.

The query also supports additional qualifiers:

   * _all$_: if _true_, all matching entities are deleted; if _false_ only the first entry in the result set; default: _false_
   * _load$_: if _true_, the first matching entry (only, and if any) is the response data; if _false_, there is no response data; default: _false_


### cmd:list

This pattern must accept:

   * q: query to select a set of entities from the underlying data store

The query qualifers are the same as for _cmd:load_.

### cmd:count

This pattern must accept:

   * q: query to select a set of entities from the underlying data store

The query qualifers are the same as for _cmd:load_.


### cmd:native

The data store should provide as a response the appropriate native API
for interacting with the database directly. This allows for full
access to database functionality, at the expense of database
independence.







